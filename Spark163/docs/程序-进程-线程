1，程序(program)
2，进程(process)
3, 线程(thread):进程可进一步细化为线程，是一个程序内部的执行路径。
                若一个程序可同一时间执行多个线程，就是支持多线程。
JVM允许程序运行多个线程，通过java.lang.Thread类来实现。
Thread类特性:
    1,每个线程都是某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体。
    2,通过该Thread对象的start()方法来调用这个线程。
Thread中常用方法:
    yield():调用此方法的线程释放当前CPU执行权
    join():在A线程中调用B线程的join()方法，表示A停止执行B插入执行，直到B执行完成后A在执行
    isAlive():判断当前线程是否存活
    sleep(long time):显式的让当前线程睡眠time毫秒
    线程通信:wait()     notify()    notifyAll()
    设置线程的优先级
线程分类：一种为守护线程，一种为用户线程。
    它们几乎在每个方面都是相同的，唯一的区别就是判断JVM何时离开
    守护线程是用来服务用户线程的，
        通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程。
    Java垃圾回收就是一个典型的守护线程。
    若JVM中都是守护线程，当前JVM将推出
同步机制：
    1,线程安全问题：由于一个线程在操作共享数据的过程中，未执行完成的情况下，
                    另外一个进程参与进来，操作了共享数据，导致出现了线程安全问题
java实现线程安全：线程的同步机制
    方式一：同步代码块
        synchronized(同步监视器){
            //需要被同步的代码块(即操作共享数据的代码)
        }
        共享数据：多个线程共同操作的同一个数据(变量)
        同步监视器：由一个对象来充当，哪个线程获取此监视器那么就执行被同步的代码。俗称：锁
    方式二：同步方法
释放锁操作: 当前线程的同步代码块或同步方法执行结束
           当前线程在同步代码块或同步方法中遇到了break，return终止了改代码块或方法
           当前线程在同步代码块或同步方法中出现了未处理的Error，Exception
           当前线程在同步代码块或同步方法中执行了线程对象的wait()方法，当前线程暂定，并且释放锁
死锁：不同的线程分别占用着对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁
线程通信：三个方法   wait()&notify()&notifyAll()
    wait() : 当前线程挂起并放弃CPU&同步资源，使别的线程可访问并修改共享资源，而当前线程排队等候再次对资源的访问
    notify() : 唤醒正在排队等待同步资源的线程中优先级最高者结束等待
    notifyAll() : 唤醒正在排队等待资源的所有线程结束等待
    ****三个方法只有在synchronized方法或synchronized代码块中才能使用。
Java定时器使用：Time&TimeTask

1.5新API的线程并发库
